// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const config = `-- name: Config :one
SELECT steam_id, steam_dir, tf2_dir, auto_launch_game, auto_close_on_game_exit, bd_api_enabled, bd_api_address, api_key, systray_enabled, disconnected_timeout, discord_presence_enabled, kicker_enabled, chat_warnings_enabled, voice_bans_enabled, debug_log_enabled, rcon_static, http_enabled, http_listen_addr, player_expired_timeout, player_disconnect_timeout, run_mode, log_level, rcon_address, rcon_port, rcon_password
FROM config
`

func (q *Queries) Config(ctx context.Context) (Config, error) {
	row := q.queryRow(ctx, q.configStmt, config)
	var i Config
	err := row.Scan(
		&i.SteamID,
		&i.SteamDir,
		&i.Tf2Dir,
		&i.AutoLaunchGame,
		&i.AutoCloseOnGameExit,
		&i.BdApiEnabled,
		&i.BdApiAddress,
		&i.ApiKey,
		&i.SystrayEnabled,
		&i.DisconnectedTimeout,
		&i.DiscordPresenceEnabled,
		&i.KickerEnabled,
		&i.ChatWarningsEnabled,
		&i.VoiceBansEnabled,
		&i.DebugLogEnabled,
		&i.RconStatic,
		&i.HttpEnabled,
		&i.HttpListenAddr,
		&i.PlayerExpiredTimeout,
		&i.PlayerDisconnectTimeout,
		&i.RunMode,
		&i.LogLevel,
		&i.RconAddress,
		&i.RconPort,
		&i.RconPassword,
	)
	return i, err
}

const configUpdate = `-- name: ConfigUpdate :exec
UPDATE config
SET steam_id                  = ?1,
    steam_dir                 = ?2,
    tf2_dir                   = ?3,
    auto_launch_game          = ?4,
    auto_close_on_game_exit   = ?5,
    bd_api_enabled            = ?6,
    bd_api_address            = ?7,
    api_key                   = ?8,
    systray_enabled           = ?9,
    disconnected_timeout      = ?10,
    discord_presence_enabled  = ?11,
    kicker_enabled            = ?12,
    chat_warnings_enabled     = ?13,
    voice_bans_enabled        = ?14,
    debug_log_enabled         = ?15,
    rcon_static               = ?16,
    http_enabled              = ?17,
    http_listen_addr          = ?18,
    player_expired_timeout    = ?19,
    player_disconnect_timeout = ?20,
    run_mode                  = ?21,
    log_level                 = ?22,
    rcon_address              = ?23,
    rcon_port                 = ?24,
    rcon_password             = ?25
`

type ConfigUpdateParams struct {
	SteamID                 string `json:"steam_id"`
	SteamDir                string `json:"steam_dir"`
	Tf2Dir                  string `json:"tf2_dir"`
	AutoLaunchGame          bool   `json:"auto_launch_game"`
	AutoCloseOnGameExit     bool   `json:"auto_close_on_game_exit"`
	BdApiEnabled            bool   `json:"bd_api_enabled"`
	BdApiAddress            string `json:"bd_api_address"`
	ApiKey                  string `json:"api_key"`
	SystrayEnabled          bool   `json:"systray_enabled"`
	DisconnectedTimeout     int64  `json:"disconnected_timeout"`
	DiscordPresenceEnabled  bool   `json:"discord_presence_enabled"`
	KickerEnabled           bool   `json:"kicker_enabled"`
	ChatWarningsEnabled     bool   `json:"chat_warnings_enabled"`
	VoiceBansEnabled        bool   `json:"voice_bans_enabled"`
	DebugLogEnabled         bool   `json:"debug_log_enabled"`
	RconStatic              bool   `json:"rcon_static"`
	HttpEnabled             bool   `json:"http_enabled"`
	HttpListenAddr          string `json:"http_listen_addr"`
	PlayerExpiredTimeout    int64  `json:"player_expired_timeout"`
	PlayerDisconnectTimeout int64  `json:"player_disconnect_timeout"`
	RunMode                 string `json:"run_mode"`
	LogLevel                string `json:"log_level"`
	RconAddress             string `json:"rcon_address"`
	RconPort                int64  `json:"rcon_port"`
	RconPassword            string `json:"rcon_password"`
}

func (q *Queries) ConfigUpdate(ctx context.Context, arg ConfigUpdateParams) error {
	_, err := q.exec(ctx, q.configUpdateStmt, configUpdate,
		arg.SteamID,
		arg.SteamDir,
		arg.Tf2Dir,
		arg.AutoLaunchGame,
		arg.AutoCloseOnGameExit,
		arg.BdApiEnabled,
		arg.BdApiAddress,
		arg.ApiKey,
		arg.SystrayEnabled,
		arg.DisconnectedTimeout,
		arg.DiscordPresenceEnabled,
		arg.KickerEnabled,
		arg.ChatWarningsEnabled,
		arg.VoiceBansEnabled,
		arg.DebugLogEnabled,
		arg.RconStatic,
		arg.HttpEnabled,
		arg.HttpListenAddr,
		arg.PlayerExpiredTimeout,
		arg.PlayerDisconnectTimeout,
		arg.RunMode,
		arg.LogLevel,
		arg.RconAddress,
		arg.RconPort,
		arg.RconPassword,
	)
	return err
}

const friends = `-- name: Friends :many
SELECT steam_id, steam_id_friend, friend_since, created_on
FROM player_friends
WHERE steam_id = ?1
`

func (q *Queries) Friends(ctx context.Context, steamID int64) ([]PlayerFriend, error) {
	rows, err := q.query(ctx, q.friendsStmt, friends, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerFriend
	for rows.Next() {
		var i PlayerFriend
		if err := rows.Scan(
			&i.SteamID,
			&i.SteamIDFriend,
			&i.FriendSince,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const friendsDelete = `-- name: FriendsDelete :exec
DELETE
FROM player_friends
WHERE steam_id = ?1
`

func (q *Queries) FriendsDelete(ctx context.Context, steamID int64) error {
	_, err := q.exec(ctx, q.friendsDeleteStmt, friendsDelete, steamID)
	return err
}

const friendsInsert = `-- name: FriendsInsert :exec
INSERT INTO player_friends (steam_id, steam_id_friend, friend_since, created_on)
VALUES (?, ?, ?, ?)
`

type FriendsInsertParams struct {
	SteamID       int64     `json:"steam_id"`
	SteamIDFriend int64     `json:"steam_id_friend"`
	FriendSince   time.Time `json:"friend_since"`
	CreatedOn     time.Time `json:"created_on"`
}

func (q *Queries) FriendsInsert(ctx context.Context, arg FriendsInsertParams) error {
	_, err := q.exec(ctx, q.friendsInsertStmt, friendsInsert,
		arg.SteamID,
		arg.SteamIDFriend,
		arg.FriendSince,
		arg.CreatedOn,
	)
	return err
}

const links = `-- name: Links :many
SELECT link_id,
       name,
       url,
       id_format,
       url,
       enabled,
       updated_on,
       created_on
FROM links
`

type LinksRow struct {
	LinkID    int64     `json:"link_id"`
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	IDFormat  string    `json:"id_format"`
	Url_2     string    `json:"url_2"`
	Enabled   bool      `json:"enabled"`
	UpdatedOn time.Time `json:"updated_on"`
	CreatedOn time.Time `json:"created_on"`
}

func (q *Queries) Links(ctx context.Context) ([]LinksRow, error) {
	rows, err := q.query(ctx, q.linksStmt, links)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LinksRow
	for rows.Next() {
		var i LinksRow
		if err := rows.Scan(
			&i.LinkID,
			&i.Name,
			&i.Url,
			&i.IDFormat,
			&i.Url_2,
			&i.Enabled,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linksDelete = `-- name: LinksDelete :exec
DELETE
FROM links
WHERE link_id = ?1
`

func (q *Queries) LinksDelete(ctx context.Context, linkID int64) error {
	_, err := q.exec(ctx, q.linksDeleteStmt, linksDelete, linkID)
	return err
}

const linksInsert = `-- name: LinksInsert :one
INSERT INTO links (link_id, name, url, id_format, enabled, created_on, updated_on)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING link_id, name, url, id_format, enabled, created_on, updated_on
`

type LinksInsertParams struct {
	LinkID    int64     `json:"link_id"`
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	IDFormat  string    `json:"id_format"`
	Enabled   bool      `json:"enabled"`
	CreatedOn time.Time `json:"created_on"`
	UpdatedOn time.Time `json:"updated_on"`
}

func (q *Queries) LinksInsert(ctx context.Context, arg LinksInsertParams) (Link, error) {
	row := q.queryRow(ctx, q.linksInsertStmt, linksInsert,
		arg.LinkID,
		arg.Name,
		arg.Url,
		arg.IDFormat,
		arg.Enabled,
		arg.CreatedOn,
		arg.UpdatedOn,
	)
	var i Link
	err := row.Scan(
		&i.LinkID,
		&i.Name,
		&i.Url,
		&i.IDFormat,
		&i.Enabled,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const linksUpdate = `-- name: LinksUpdate :exec
UPDATE links
SET link_id    = ?1,
    name       = ?2,
    url        = ?3,
    id_format  = ?4,
    enabled    = ?5,
    updated_on = ?6
WHERE link_id = ?1
`

type LinksUpdateParams struct {
	LinkID    int64     `json:"link_id"`
	Name      string    `json:"name"`
	Url       string    `json:"url"`
	IDFormat  string    `json:"id_format"`
	Enabled   bool      `json:"enabled"`
	UpdatedOn time.Time `json:"updated_on"`
}

func (q *Queries) LinksUpdate(ctx context.Context, arg LinksUpdateParams) error {
	_, err := q.exec(ctx, q.linksUpdateStmt, linksUpdate,
		arg.LinkID,
		arg.Name,
		arg.Url,
		arg.IDFormat,
		arg.Enabled,
		arg.UpdatedOn,
	)
	return err
}

const lists = `-- name: Lists :many
SELECT list_id, list_type, url, enabled, name, updated_on, created_on
FROM lists
`

type ListsRow struct {
	ListID    int64     `json:"list_id"`
	ListType  int64     `json:"list_type"`
	Url       string    `json:"url"`
	Enabled   bool      `json:"enabled"`
	Name      string    `json:"name"`
	UpdatedOn time.Time `json:"updated_on"`
	CreatedOn time.Time `json:"created_on"`
}

func (q *Queries) Lists(ctx context.Context) ([]ListsRow, error) {
	rows, err := q.query(ctx, q.listsStmt, lists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListsRow
	for rows.Next() {
		var i ListsRow
		if err := rows.Scan(
			&i.ListID,
			&i.ListType,
			&i.Url,
			&i.Enabled,
			&i.Name,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listsDelete = `-- name: ListsDelete :exec
DELETE
FROM lists
WHERE list_id = ?1
`

func (q *Queries) ListsDelete(ctx context.Context, listID int64) error {
	_, err := q.exec(ctx, q.listsDeleteStmt, listsDelete, listID)
	return err
}

const listsInsert = `-- name: ListsInsert :one
INSERT INTO lists (list_type, url, enabled, updated_on, created_on)
VALUES (?, ?, ?, ?, ?)
RETURNING list_id, list_type, url, enabled, updated_on, created_on, name
`

type ListsInsertParams struct {
	ListType  int64     `json:"list_type"`
	Url       string    `json:"url"`
	Enabled   bool      `json:"enabled"`
	UpdatedOn time.Time `json:"updated_on"`
	CreatedOn time.Time `json:"created_on"`
}

func (q *Queries) ListsInsert(ctx context.Context, arg ListsInsertParams) (List, error) {
	row := q.queryRow(ctx, q.listsInsertStmt, listsInsert,
		arg.ListType,
		arg.Url,
		arg.Enabled,
		arg.UpdatedOn,
		arg.CreatedOn,
	)
	var i List
	err := row.Scan(
		&i.ListID,
		&i.ListType,
		&i.Url,
		&i.Enabled,
		&i.UpdatedOn,
		&i.CreatedOn,
		&i.Name,
	)
	return i, err
}

const listsUpdate = `-- name: ListsUpdate :exec
UPDATE lists
SET list_type  = ?1,
    url        = ?2,
    enabled    = ?3,
    updated_on = ?4
WHERE list_id = ?5
`

type ListsUpdateParams struct {
	ListType  int64     `json:"list_type"`
	Url       string    `json:"url"`
	Enabled   bool      `json:"enabled"`
	UpdatedOn time.Time `json:"updated_on"`
	ListID    int64     `json:"list_id"`
}

func (q *Queries) ListsUpdate(ctx context.Context, arg ListsUpdateParams) error {
	_, err := q.exec(ctx, q.listsUpdateStmt, listsUpdate,
		arg.ListType,
		arg.Url,
		arg.Enabled,
		arg.UpdatedOn,
		arg.ListID,
	)
	return err
}

const messageSave = `-- name: MessageSave :exec
INSERT INTO player_messages (steam_id, message, team, dead, created_on)
VALUES (?, ?, ?, ?, ?)
`

type MessageSaveParams struct {
	SteamID   int64     `json:"steam_id"`
	Message   string    `json:"message"`
	Team      bool      `json:"team"`
	Dead      bool      `json:"dead"`
	CreatedOn time.Time `json:"created_on"`
}

func (q *Queries) MessageSave(ctx context.Context, arg MessageSaveParams) error {
	_, err := q.exec(ctx, q.messageSaveStmt, messageSave,
		arg.SteamID,
		arg.Message,
		arg.Team,
		arg.Dead,
		arg.CreatedOn,
	)
	return err
}

const messages = `-- name: Messages :many
SELECT message_id, steam_id, message, team, dead, created_on
FROM player_messages
WHERE steam_id = ?1
`

func (q *Queries) Messages(ctx context.Context, steamID int64) ([]PlayerMessage, error) {
	rows, err := q.query(ctx, q.messagesStmt, messages, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerMessage
	for rows.Next() {
		var i PlayerMessage
		if err := rows.Scan(
			&i.MessageID,
			&i.SteamID,
			&i.Message,
			&i.Team,
			&i.Dead,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const player = `-- name: Player :one
SELECT p.steam_id,
       p.visibility,
       p.real_name,
       p.account_created_on,
       p.avatar_hash,
       p.community_banned,
       p.game_bans,
       p.vac_bans,
       p.last_vac_ban_on,
       p.kills_on,
       p.deaths_by,
       p.rage_quits,
       p.notes,
       p.whitelist,
       p.created_on,
       p.updated_on,
       p.profile_updated_on,
       p.personaname
FROM player p
WHERE p.steam_id = ?1
`

type PlayerRow struct {
	SteamID          int64        `json:"steam_id"`
	Visibility       int64        `json:"visibility"`
	RealName         string       `json:"real_name"`
	AccountCreatedOn time.Time    `json:"account_created_on"`
	AvatarHash       string       `json:"avatar_hash"`
	CommunityBanned  bool         `json:"community_banned"`
	GameBans         int64        `json:"game_bans"`
	VacBans          int64        `json:"vac_bans"`
	LastVacBanOn     sql.NullTime `json:"last_vac_ban_on"`
	KillsOn          int64        `json:"kills_on"`
	DeathsBy         int64        `json:"deaths_by"`
	RageQuits        int64        `json:"rage_quits"`
	Notes            string       `json:"notes"`
	Whitelist        bool         `json:"whitelist"`
	CreatedOn        time.Time    `json:"created_on"`
	UpdatedOn        time.Time    `json:"updated_on"`
	ProfileUpdatedOn time.Time    `json:"profile_updated_on"`
	Personaname      string       `json:"personaname"`
}

func (q *Queries) Player(ctx context.Context, steamID int64) (PlayerRow, error) {
	row := q.queryRow(ctx, q.playerStmt, player, steamID)
	var i PlayerRow
	err := row.Scan(
		&i.SteamID,
		&i.Visibility,
		&i.RealName,
		&i.AccountCreatedOn,
		&i.AvatarHash,
		&i.CommunityBanned,
		&i.GameBans,
		&i.VacBans,
		&i.LastVacBanOn,
		&i.KillsOn,
		&i.DeathsBy,
		&i.RageQuits,
		&i.Notes,
		&i.Whitelist,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.ProfileUpdatedOn,
		&i.Personaname,
	)
	return i, err
}

const playerInsert = `-- name: PlayerInsert :one
INSERT INTO player (steam_id, personaname, visibility, real_name, account_created_on,
                    avatar_hash, community_banned, game_bans, vac_bans, last_vac_ban_on,
                    kills_on, deaths_by, rage_quits, notes, whitelist, profile_updated_on,
                    created_on, updated_on)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING steam_id, personaname, visibility, real_name, account_created_on, avatar_hash, community_banned, game_bans, vac_bans, last_vac_ban_on, kills_on, deaths_by, rage_quits, notes, whitelist, profile_updated_on, created_on, updated_on
`

type PlayerInsertParams struct {
	SteamID          int64        `json:"steam_id"`
	Personaname      string       `json:"personaname"`
	Visibility       int64        `json:"visibility"`
	RealName         string       `json:"real_name"`
	AccountCreatedOn time.Time    `json:"account_created_on"`
	AvatarHash       string       `json:"avatar_hash"`
	CommunityBanned  bool         `json:"community_banned"`
	GameBans         int64        `json:"game_bans"`
	VacBans          int64        `json:"vac_bans"`
	LastVacBanOn     sql.NullTime `json:"last_vac_ban_on"`
	KillsOn          int64        `json:"kills_on"`
	DeathsBy         int64        `json:"deaths_by"`
	RageQuits        int64        `json:"rage_quits"`
	Notes            string       `json:"notes"`
	Whitelist        bool         `json:"whitelist"`
	ProfileUpdatedOn time.Time    `json:"profile_updated_on"`
	CreatedOn        time.Time    `json:"created_on"`
	UpdatedOn        time.Time    `json:"updated_on"`
}

func (q *Queries) PlayerInsert(ctx context.Context, arg PlayerInsertParams) (Player, error) {
	row := q.queryRow(ctx, q.playerInsertStmt, playerInsert,
		arg.SteamID,
		arg.Personaname,
		arg.Visibility,
		arg.RealName,
		arg.AccountCreatedOn,
		arg.AvatarHash,
		arg.CommunityBanned,
		arg.GameBans,
		arg.VacBans,
		arg.LastVacBanOn,
		arg.KillsOn,
		arg.DeathsBy,
		arg.RageQuits,
		arg.Notes,
		arg.Whitelist,
		arg.ProfileUpdatedOn,
		arg.CreatedOn,
		arg.UpdatedOn,
	)
	var i Player
	err := row.Scan(
		&i.SteamID,
		&i.Personaname,
		&i.Visibility,
		&i.RealName,
		&i.AccountCreatedOn,
		&i.AvatarHash,
		&i.CommunityBanned,
		&i.GameBans,
		&i.VacBans,
		&i.LastVacBanOn,
		&i.KillsOn,
		&i.DeathsBy,
		&i.RageQuits,
		&i.Notes,
		&i.Whitelist,
		&i.ProfileUpdatedOn,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const playerSearch = `-- name: PlayerSearch :many
SELECT p.steam_id,
       p.visibility,
       p.real_name,
       p.account_created_on,
       p.avatar_hash,
       p.community_banned,
       p.game_bans,
       p.vac_bans,
       p.last_vac_ban_on,
       p.kills_on,
       p.deaths_by,
       p.rage_quits,
       p.notes,
       p.whitelist,
       p.profile_updated_on,
       p.created_on,
       p.updated_on,
       p.personaname
FROM player p
WHERE (?1 = 0 OR p.steam_id = ?1)
  AND (?2 IS '' OR p.personaname LIKE ?2)
ORDER BY p.updated_on DESC
LIMIT 1000
`

type PlayerSearchParams struct {
	SteamID interface{} `json:"steam_id"`
	Name    interface{} `json:"name"`
}

type PlayerSearchRow struct {
	SteamID          int64        `json:"steam_id"`
	Visibility       int64        `json:"visibility"`
	RealName         string       `json:"real_name"`
	AccountCreatedOn time.Time    `json:"account_created_on"`
	AvatarHash       string       `json:"avatar_hash"`
	CommunityBanned  bool         `json:"community_banned"`
	GameBans         int64        `json:"game_bans"`
	VacBans          int64        `json:"vac_bans"`
	LastVacBanOn     sql.NullTime `json:"last_vac_ban_on"`
	KillsOn          int64        `json:"kills_on"`
	DeathsBy         int64        `json:"deaths_by"`
	RageQuits        int64        `json:"rage_quits"`
	Notes            string       `json:"notes"`
	Whitelist        bool         `json:"whitelist"`
	ProfileUpdatedOn time.Time    `json:"profile_updated_on"`
	CreatedOn        time.Time    `json:"created_on"`
	UpdatedOn        time.Time    `json:"updated_on"`
	Personaname      string       `json:"personaname"`
}

func (q *Queries) PlayerSearch(ctx context.Context, arg PlayerSearchParams) ([]PlayerSearchRow, error) {
	rows, err := q.query(ctx, q.playerSearchStmt, playerSearch, arg.SteamID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerSearchRow
	for rows.Next() {
		var i PlayerSearchRow
		if err := rows.Scan(
			&i.SteamID,
			&i.Visibility,
			&i.RealName,
			&i.AccountCreatedOn,
			&i.AvatarHash,
			&i.CommunityBanned,
			&i.GameBans,
			&i.VacBans,
			&i.LastVacBanOn,
			&i.KillsOn,
			&i.DeathsBy,
			&i.RageQuits,
			&i.Notes,
			&i.Whitelist,
			&i.ProfileUpdatedOn,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.Personaname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playerUpdate = `-- name: PlayerUpdate :exec
UPDATE player
SET visibility         = ?1,
    real_name          = ?2,
    account_created_on = ?3,
    avatar_hash        = ?4,
    community_banned   = ?5,
    game_bans          = ?6,
    vac_bans           = ?7,
    last_vac_ban_on    = ?8,
    kills_on           = ?9,
    deaths_by          = ?10,
    rage_quits         = ?11,
    notes              = ?12,
    whitelist          = ?13,
    updated_on         = ?14,
    profile_updated_on = ?15,
    personaname        = ?16
WHERE steam_id = ?17
`

type PlayerUpdateParams struct {
	Visibility       int64        `json:"visibility"`
	RealName         string       `json:"real_name"`
	AccountCreatedOn time.Time    `json:"account_created_on"`
	AvatarHash       string       `json:"avatar_hash"`
	CommunityBanned  bool         `json:"community_banned"`
	GameBans         int64        `json:"game_bans"`
	VacBans          int64        `json:"vac_bans"`
	LastVacBanOn     sql.NullTime `json:"last_vac_ban_on"`
	KillsOn          int64        `json:"kills_on"`
	DeathsBy         int64        `json:"deaths_by"`
	RageQuits        int64        `json:"rage_quits"`
	Notes            string       `json:"notes"`
	Whitelist        bool         `json:"whitelist"`
	UpdatedOn        time.Time    `json:"updated_on"`
	ProfileUpdatedOn time.Time    `json:"profile_updated_on"`
	Personaname      string       `json:"personaname"`
	SteamID          int64        `json:"steam_id"`
}

func (q *Queries) PlayerUpdate(ctx context.Context, arg PlayerUpdateParams) error {
	_, err := q.exec(ctx, q.playerUpdateStmt, playerUpdate,
		arg.Visibility,
		arg.RealName,
		arg.AccountCreatedOn,
		arg.AvatarHash,
		arg.CommunityBanned,
		arg.GameBans,
		arg.VacBans,
		arg.LastVacBanOn,
		arg.KillsOn,
		arg.DeathsBy,
		arg.RageQuits,
		arg.Notes,
		arg.Whitelist,
		arg.UpdatedOn,
		arg.ProfileUpdatedOn,
		arg.Personaname,
		arg.SteamID,
	)
	return err
}

const sourcebans = `-- name: Sourcebans :many
SELECT sourcebans_id,
       steam_id,
       site,
       player_name,
       reason,
       duration,
       permanent,
       created_on
FROM player_sourcebans
WHERE steam_id = ?1
`

func (q *Queries) Sourcebans(ctx context.Context, steamID int64) ([]PlayerSourceban, error) {
	rows, err := q.query(ctx, q.sourcebansStmt, sourcebans, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerSourceban
	for rows.Next() {
		var i PlayerSourceban
		if err := rows.Scan(
			&i.SourcebansID,
			&i.SteamID,
			&i.Site,
			&i.PlayerName,
			&i.Reason,
			&i.Duration,
			&i.Permanent,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sourcebansDelete = `-- name: SourcebansDelete :exec
DELETE
FROM player_sourcebans
WHERE steam_id = ?1
`

func (q *Queries) SourcebansDelete(ctx context.Context, steamID int64) error {
	_, err := q.exec(ctx, q.sourcebansDeleteStmt, sourcebansDelete, steamID)
	return err
}

const sourcebansInsert = `-- name: SourcebansInsert :one
INSERT INTO player_sourcebans (steam_id, site, player_name, reason, duration, permanent, created_on)
VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING sourcebans_id, steam_id, site, player_name, reason, duration, permanent, created_on
`

type SourcebansInsertParams struct {
	SteamID    int64     `json:"steam_id"`
	Site       string    `json:"site"`
	PlayerName string    `json:"player_name"`
	Reason     string    `json:"reason"`
	Duration   int64     `json:"duration"`
	Permanent  bool      `json:"permanent"`
	CreatedOn  time.Time `json:"created_on"`
}

func (q *Queries) SourcebansInsert(ctx context.Context, arg SourcebansInsertParams) (PlayerSourceban, error) {
	row := q.queryRow(ctx, q.sourcebansInsertStmt, sourcebansInsert,
		arg.SteamID,
		arg.Site,
		arg.PlayerName,
		arg.Reason,
		arg.Duration,
		arg.Permanent,
		arg.CreatedOn,
	)
	var i PlayerSourceban
	err := row.Scan(
		&i.SourcebansID,
		&i.SteamID,
		&i.Site,
		&i.PlayerName,
		&i.Reason,
		&i.Duration,
		&i.Permanent,
		&i.CreatedOn,
	)
	return i, err
}

const userNameSave = `-- name: UserNameSave :exec
INSERT INTO player_names (name_id, steam_id, name, created_on)
VALUES (?, ?, ?, ?)
`

type UserNameSaveParams struct {
	NameID    int64     `json:"name_id"`
	SteamID   int64     `json:"steam_id"`
	Name      string    `json:"name"`
	CreatedOn time.Time `json:"created_on"`
}

func (q *Queries) UserNameSave(ctx context.Context, arg UserNameSaveParams) error {
	_, err := q.exec(ctx, q.userNameSaveStmt, userNameSave,
		arg.NameID,
		arg.SteamID,
		arg.Name,
		arg.CreatedOn,
	)
	return err
}

const userNames = `-- name: UserNames :many
SELECT name_id, steam_id, name, created_on
FROM player_names
WHERE steam_id = ?1
`

func (q *Queries) UserNames(ctx context.Context, steamID int64) ([]PlayerName, error) {
	rows, err := q.query(ctx, q.userNamesStmt, userNames, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerName
	for rows.Next() {
		var i PlayerName
		if err := rows.Scan(
			&i.NameID,
			&i.SteamID,
			&i.Name,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
