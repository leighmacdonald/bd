// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
	"time"
)

const messageSave = `-- name: MessageSave :exec
INSERT INTO player_messages (message_id, steam_id, message, created_on)
VALUES (?, ?, ?, ?)
`

type MessageSaveParams struct {
	MessageID int64
	SteamID   int64
	Message   string
	CreatedOn time.Time
}

func (q *Queries) MessageSave(ctx context.Context, arg MessageSaveParams) error {
	_, err := q.db.ExecContext(ctx, messageSave,
		arg.MessageID,
		arg.SteamID,
		arg.Message,
		arg.CreatedOn,
	)
	return err
}

const messages = `-- name: Messages :many
SELECT message_id, steam_id, message, created_on
    FROM player_messages
WHERE steam_id = ?1
`

func (q *Queries) Messages(ctx context.Context, steamID int64) ([]PlayerMessage, error) {
	rows, err := q.db.QueryContext(ctx, messages, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerMessage
	for rows.Next() {
		var i PlayerMessage
		if err := rows.Scan(
			&i.MessageID,
			&i.SteamID,
			&i.Message,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const player = `-- name: Player :one
SELECT p.visibility,
       p.real_name,
       p.account_created_on,
       p.avatar_hash,
       p.community_banned,
       p.game_bans,
       p.vac_bans,
       p.last_vac_ban_on,
       p.kills_on,
       p.deaths_by,
       p.rage_quits,
       p.notes,
       p.whitelist,
       p.created_on,
       p.updated_on,
       p.profile_updated_on,
       pn.name
FROm player p
         LEFT JOIN player_names pn on p.steam_id = pn.steam_id
WHERE p.steam_id = ?1
ORDER BY pn.created_on DESC
LIMIT 1
`

type PlayerRow struct {
	Visibility       int64
	RealName         string
	AccountCreatedOn time.Time
	AvatarHash       string
	CommunityBanned  int64
	GameBans         int64
	VacBans          int64
	LastVacBanOn     sql.NullTime
	KillsOn          int64
	DeathsBy         int64
	RageQuits        int64
	Notes            string
	Whitelist        bool
	CreatedOn        time.Time
	UpdatedOn        time.Time
	ProfileUpdatedOn time.Time
	Name             sql.NullString
}

func (q *Queries) Player(ctx context.Context, steamID sql.NullInt64) (PlayerRow, error) {
	row := q.db.QueryRowContext(ctx, player, steamID)
	var i PlayerRow
	err := row.Scan(
		&i.Visibility,
		&i.RealName,
		&i.AccountCreatedOn,
		&i.AvatarHash,
		&i.CommunityBanned,
		&i.GameBans,
		&i.VacBans,
		&i.LastVacBanOn,
		&i.KillsOn,
		&i.DeathsBy,
		&i.RageQuits,
		&i.Notes,
		&i.Whitelist,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.ProfileUpdatedOn,
		&i.Name,
	)
	return i, err
}

const playerInsert = `-- name: PlayerInsert :one
INSERT INTO player (steam_id, visibility, real_name, account_created_on,
                    avatar_hash, community_banned, game_bans, vac_bans, last_vac_ban_on,
                    kills_on, deaths_by, rage_quits, notes, whitelist, profile_updated_on,
                    created_on, updated_on)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING steam_id, visibility, real_name, account_created_on, avatar_hash, community_banned, game_bans, vac_bans, last_vac_ban_on, kills_on, deaths_by, rage_quits, notes, whitelist, profile_updated_on, created_on, updated_on
`

type PlayerInsertParams struct {
	SteamID          sql.NullInt64
	Visibility       int64
	RealName         string
	AccountCreatedOn time.Time
	AvatarHash       string
	CommunityBanned  int64
	GameBans         int64
	VacBans          int64
	LastVacBanOn     sql.NullTime
	KillsOn          int64
	DeathsBy         int64
	RageQuits        int64
	Notes            string
	Whitelist        bool
	ProfileUpdatedOn time.Time
	CreatedOn        time.Time
	UpdatedOn        time.Time
}

func (q *Queries) PlayerInsert(ctx context.Context, arg PlayerInsertParams) (Player, error) {
	row := q.db.QueryRowContext(ctx, playerInsert,
		arg.SteamID,
		arg.Visibility,
		arg.RealName,
		arg.AccountCreatedOn,
		arg.AvatarHash,
		arg.CommunityBanned,
		arg.GameBans,
		arg.VacBans,
		arg.LastVacBanOn,
		arg.KillsOn,
		arg.DeathsBy,
		arg.RageQuits,
		arg.Notes,
		arg.Whitelist,
		arg.ProfileUpdatedOn,
		arg.CreatedOn,
		arg.UpdatedOn,
	)
	var i Player
	err := row.Scan(
		&i.SteamID,
		&i.Visibility,
		&i.RealName,
		&i.AccountCreatedOn,
		&i.AvatarHash,
		&i.CommunityBanned,
		&i.GameBans,
		&i.VacBans,
		&i.LastVacBanOn,
		&i.KillsOn,
		&i.DeathsBy,
		&i.RageQuits,
		&i.Notes,
		&i.Whitelist,
		&i.ProfileUpdatedOn,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const playerSearch = `-- name: PlayerSearch :many
SELECT p.steam_id,
       p.visibility,
       p.real_name,
       p.account_created_on,
       p.avatar_hash,
       p.community_banned,
       p.game_bans,
       p.vac_bans,
       p.last_vac_ban_on,
       p.kills_on,
       p.deaths_by,
       p.rage_quits,
       p.notes,
       p.whitelist,
       p.profile_updated_on,
       p.created_on,
       p.updated_on,
       pn.name
FROM player p
         LEFT JOIN player_names pn on p.steam_id = pn.steam_id
WHERE (?1 = 0 OR p.steam_id = ?1)
  AND (?2 IS '' OR pn.name LIKE ?2)
ORDER BY p.updated_on DESC
LIMIT 1000
`

type PlayerSearchParams struct {
	SteamID interface{}
	Name    interface{}
}

type PlayerSearchRow struct {
	SteamID          sql.NullInt64
	Visibility       int64
	RealName         string
	AccountCreatedOn time.Time
	AvatarHash       string
	CommunityBanned  int64
	GameBans         int64
	VacBans          int64
	LastVacBanOn     sql.NullTime
	KillsOn          int64
	DeathsBy         int64
	RageQuits        int64
	Notes            string
	Whitelist        bool
	ProfileUpdatedOn time.Time
	CreatedOn        time.Time
	UpdatedOn        time.Time
	Name             sql.NullString
}

func (q *Queries) PlayerSearch(ctx context.Context, arg PlayerSearchParams) ([]PlayerSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, playerSearch, arg.SteamID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerSearchRow
	for rows.Next() {
		var i PlayerSearchRow
		if err := rows.Scan(
			&i.SteamID,
			&i.Visibility,
			&i.RealName,
			&i.AccountCreatedOn,
			&i.AvatarHash,
			&i.CommunityBanned,
			&i.GameBans,
			&i.VacBans,
			&i.LastVacBanOn,
			&i.KillsOn,
			&i.DeathsBy,
			&i.RageQuits,
			&i.Notes,
			&i.Whitelist,
			&i.ProfileUpdatedOn,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playerUpdate = `-- name: PlayerUpdate :exec
UPDATE player
SET visibility         = ?1,
    real_name          = ?2,
    account_created_on = ?3,
    avatar_hash        = ?4,
    community_banned   = ?5,
    game_bans          = ?6,
    vac_bans           = ?7,
    last_vac_ban_on    = ?8,
    kills_on           = ?9,
    deaths_by          = ?10,
    rage_quits         = ?11,
    notes              = ?12,
    whitelist          = ?13,
    updated_on         = ?14,
    profile_updated_on = ?15
WHERE steam_id = ?16
`

type PlayerUpdateParams struct {
	Visibility       int64
	RealName         string
	AccountCreatedOn time.Time
	AvatarHash       string
	CommunityBanned  int64
	GameBans         int64
	VacBans          int64
	LastVacBanOn     sql.NullTime
	KillsOn          int64
	DeathsBy         int64
	RageQuits        int64
	Notes            string
	Whitelist        bool
	UpdatedOn        time.Time
	ProfileUpdatedOn time.Time
	SteamID          sql.NullInt64
}

func (q *Queries) PlayerUpdate(ctx context.Context, arg PlayerUpdateParams) error {
	_, err := q.db.ExecContext(ctx, playerUpdate,
		arg.Visibility,
		arg.RealName,
		arg.AccountCreatedOn,
		arg.AvatarHash,
		arg.CommunityBanned,
		arg.GameBans,
		arg.VacBans,
		arg.LastVacBanOn,
		arg.KillsOn,
		arg.DeathsBy,
		arg.RageQuits,
		arg.Notes,
		arg.Whitelist,
		arg.UpdatedOn,
		arg.ProfileUpdatedOn,
		arg.SteamID,
	)
	return err
}

const userNameSave = `-- name: UserNameSave :exec
INSERT INTO player_names (name_id, steam_id, name, created_on)
VALUES (?, ?, ?, ?)
`

type UserNameSaveParams struct {
	NameID    int64
	SteamID   int64
	Name      string
	CreatedOn time.Time
}

func (q *Queries) UserNameSave(ctx context.Context, arg UserNameSaveParams) error {
	_, err := q.db.ExecContext(ctx, userNameSave,
		arg.NameID,
		arg.SteamID,
		arg.Name,
		arg.CreatedOn,
	)
	return err
}

const userNames = `-- name: UserNames :many
SELECT name_id, steam_id, name, created_on
FROM player_names
WHERE steam_id = ?1
`

func (q *Queries) UserNames(ctx context.Context, steamID int64) ([]PlayerName, error) {
	rows, err := q.db.QueryContext(ctx, userNames, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerName
	for rows.Next() {
		var i PlayerName
		if err := rows.Scan(
			&i.NameID,
			&i.SteamID,
			&i.Name,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
